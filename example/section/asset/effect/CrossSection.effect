// cross-section effect
{
    "name"  	: "cross-section",
    	
    "attributes" : {
        "aPosition"             : "geometry[${geometryUuid}].position"
    },
	
	"uniforms"	: {
		"uModelToWorldMatrix"	: "modelToWorldMatrix",
		"uWorldToScreenMatrix"	: { "binding" : { "property" : "worldToScreenMatrix", "source" : "renderer" } },
        "uClippingPlane"        : { "binding" : { "property" : "clippingPlane", "source" : "root" } }
	},
    
    "macros" : {
		"MODEL_TO_WORLD"		: "modelToWorldMatrix"
    },
    
    "defaultTechnique"  : "default",

    "states" : {
        "triangleCulling" : "material[${materialUuid}].triangleCulling"
    },

	"techniques" : [
        {
            "name" : "default",
            "passes" : [
                "render-depth",
                "render-back",
                "render-front"
            ]
    	}
    ],
    "passes" : [
        {
            // Draw capping polygons in depth buffer only
            "name" : "render-depth",
            "states" : {
                "colorMask" : false,
                "depthMask" : true,
                "triangleCulling" : "none"
            },

            "vertexShader" : "
                #ifdef GL_ES
                    #ifdef GL_FRAGMENT_PRECISION_HIGH
                        precision highp float;
                    #else
                        precision mediump float;
                    #endif
                #endif

                uniform mat4 uModelToWorldMatrix;
                uniform mat4 uWorldToScreenMatrix;
                uniform vec4 uClippingPlane;

                attribute vec3 aPosition;

                varying float clipDist;

                void main(void)
                {
                    vec4 pos = vec4(aPosition, 1.0);

                    #ifdef MODEL_TO_WORLD
                        pos = uModelToWorldMatrix * pos;
                    #endif

                    gl_Position = uWorldToScreenMatrix * pos;

                    // Compute the distance between the vertex and the clip plane
                    clipDist = dot(pos.xyz, uClippingPlane.xyz) - uClippingPlane.w;
                }
            ",
            "fragmentShader" : "
                uniform vec4 uClippingPlane;

                varying float clipDist;

                void main(void)
                {
                    if (clipDist + 0.00001 < -uClippingPlane.w * 2)
                        discard;

                    gl_FragColor = vec4(1.0, 0, 0, 0);
                }
            "
        },
        {
            "name" : "render-back",
            "states" : {
                "colorMask" : false,
                "depthMask" : false,
                "stencilFunction" : "always",
                "stencilZPassOperation" : "incr",
                "triangleCulling" : "back"
            },
            "vertexShader" : "
                #ifdef GL_ES
                    #ifdef GL_FRAGMENT_PRECISION_HIGH
                        precision highp float;
                    #else
                        precision mediump float;
                    #endif
                #endif

                uniform mat4 uModelToWorldMatrix;
                uniform mat4 uWorldToScreenMatrix;

                attribute vec3 aPosition;

                void main(void)
                {
                    vec4 pos = vec4(aPosition, 1.0);

                    #ifdef MODEL_TO_WORLD
                        pos = uModelToWorldMatrix * pos;
                    #endif

                    gl_Position = uWorldToScreenMatrix * pos;
                }
            ",
            "fragmentShader" : "
                void main(void)
                {
                    gl_FragColor = vec4(1.0, 0, 0, 0);
                }
            "
        },
        {
            "name" : "render-front",
            "states" : {
                "colorMask" : false,
                "depthMask" : false,
                "stencilFunction" : "always",
                "stencilZPassOperation" : "decr",
                "triangleCulling" : "front"
            },
            "vertexShader" : "
                #ifdef GL_ES
                    #ifdef GL_FRAGMENT_PRECISION_HIGH
                        precision highp float;
                    #else
                        precision mediump float;
                    #endif
                #endif

                uniform mat4 uModelToWorldMatrix;
                uniform mat4 uWorldToScreenMatrix;

                attribute vec3 aPosition;

                void main(void)
                {
                    vec4 pos = vec4(aPosition, 1.0);

                    #ifdef MODEL_TO_WORLD
                        pos = uModelToWorldMatrix * pos;
                    #endif

                    gl_Position = uWorldToScreenMatrix * pos;
                }
            ",
            "fragmentShader" : "
                void main(void)
                {
                    gl_FragColor = vec4(0, 0, 0, 0);
                }
            "
        }
    ]
    
}
